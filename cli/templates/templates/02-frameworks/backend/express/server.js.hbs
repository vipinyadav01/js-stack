const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
require('dotenv').config();
{{#if useJWT}}const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
{{#if usePassport}}const passport = require('passport');
const { Strategy: JwtStrategy, ExtractJwt } = require('passport-jwt');{{/if}}
{{#if usePrisma}}const { PrismaClient } = require('@prisma/client');{{/if}}
{{#if useMongoose}}const mongoose = require('mongoose');{{/if}}
{{#if useRedis}}const { createClient } = require('redis');{{/if}}
{{#if useSocketIO}}const { createServer } = require('http');
const { Server } = require('socket.io');{{/if}}
require('express-async-errors');

const app = express();
const PORT = process.env.PORT || {{backendPort}};
{{/if}}

{{#if usePrisma}}
const prisma = new PrismaClient();
{{/if}}

{{#if useRedis}}
const redisClient = createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379'
});

redisClient.on('error', (err) => console.error('Redis Client Error', err));
redisClient.connect();
{{/if}}

{{#if useSocketIO}}
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
  }
});
{{/if}}

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(compression());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('dev'));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api', limiter);

{{#if usePassport}}
// Passport JWT Strategy
passport.use(
  new JwtStrategy(
    {
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key'
    },
    async (payload, done) => {
      try {
        {{#if usePrisma}}
        const user = await prisma.user.findUnique({
          where: { id: payload.id }
        });
        {{else}}
        // Find user by ID
        const user = { id: payload.id, email: payload.email };
        {{/if}}
        
        if (user) {
          return done(null, user);
        }
        return done(null, false);
      } catch (error) {
        return done(error, false);
      }
    }
  )
);

app.use(passport.initialize());
{{/if}}

{{#if useMongoose}}
// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/{{projectName}}')
  .then(() => console.log('Connected to MongoDB'))
  .catch((err) => console.error('MongoDB connection error:', err));
{{/if}}

// Routes
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

{{#if useJWT}}
// Auth Routes
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    {{#if usePrisma}}
    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword
      }
    });
    {{else}}
    // Create user (implement your user creation logic)
    const user = { id: Date.now(), email };
    {{/if}}
    
    // Generate token
    const token = jwt.sign(
      { id: user.id, email: user.email },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    res.json({ token, user: { id: user.id, email: user.email } });
  } catch (error) {
    res.status(400).json({ error: 'Registration failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    {{#if usePrisma}}
    // Find user
    const user = await prisma.user.findUnique({
      where: { email }
    });
    {{else}}
    // Find user (implement your user lookup logic)
    const user = { id: 1, email, password: '$2a$10$...' }; // Example
    {{/if}}
    
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Generate token
    const token = jwt.sign(
      { id: user.id, email: user.email },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    res.json({ token, user: { id: user.id, email: user.email } });
  } catch (error) {
    res.status(400).json({ error: 'Login failed' });
  }
});
{{/if}}

// Example protected route
app.get('/api/protected',
  {{#if usePassport}}passport.authenticate('jwt', { session: false }),{{/if}}
  (req, res) => {
    res.json({
      message: 'This is a protected route',
      user: {{#if usePassport}}req.user{{else}}{ id: 1, email: 'user@example.com' }{{/if}}
    });
  }
);

{{#if useSocketIO}}
// Socket.io connection
io.on('connection', (socket) => {
  console.log('New client connected:', socket.id);
  
  socket.on('message', (data) => {
    console.log('Message received:', data);
    io.emit('message', data);
  });
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});
{{/if}}

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: 'Something went wrong!',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// Start server
{{#if useSocketIO}}
httpServer.listen(PORT, () => {
  console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
  console.log(`ðŸ”Œ WebSocket ready for connections`);
});
{{else}}
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
});
{{/if}}

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM signal received: closing HTTP server');
  {{#if usePrisma}}
  await prisma.$disconnect();
  {{/if}}
  {{#if useMongoose}}
  await mongoose.connection.close();
  {{/if}}
  {{#if useRedis}}
  await redisClient.quit();
  {{/if}}
  process.exit(0);
});
